<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>git-checkout(1)</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="manpage">
<div id="header">
<h1>
git-checkout(1) Manual Page
</h1>
<h2>NAME</h2>
<div class="sectionbody">
<p>git-checkout -
   Alterne filiais ou restaure arquivos da árvore de trabalho
</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_sinopse">SINOPSE</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git checkout</em> [-q] [-f] [-m] [&lt;branch&gt;]
<em>git checkout</em> [-q] [-f] [-m] --detach [&lt;branch&gt;]
<em>git checkout</em> [-q] [-f] [-m] [--detach] &lt;commit&gt;
<em>git checkout</em> [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]
<em>git checkout</em> [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;&#8230;
<em>git checkout</em> [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;&#8230;
<em>git checkout</em> (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;&#8230;]</pre>
<div class="attribution">
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição">DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph"><p>Atualiza arquivos na árvore de trabalho para corresponder à versão no índice
ou na árvore especificada.  Se nenhum caminho for fornecido, <em>git checkout</em>
também atualizará <code>HEAD</code> para definir o ramo especificado como o ramo atual.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<em>git confira</em> &lt;branch&gt;
</dt>
<dd>
<p>
        Para se preparar para trabalhar em &lt;branch&gt;, alterne para ele atualizando o
        índice e os arquivos na árvore de trabalho e apontando HEAD na
        ramificação. As modificações locais nos arquivos na árvore de trabalho são
        mantidas, para que possam ser confirmadas no &lt;branch&gt;.
</p>
<div class="paragraph"><p>Se &lt;branch&gt; não for encontrado, mas existir uma ramificação de rastreamento
em exatamente um controle remoto (chamá-lo &lt;remoto&gt;) com um nome
correspondente, trate como equivalente a</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar -b &lt;branch&gt; --rastrear &lt;remoto&gt;/&lt;branch&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Se o branch existir em múltiplos controles remotos e um deles for nomeado
pela variável de configuração <code>verificar.padrãoRemoto</code>, usaremos aquele para
propósitos de desambiguação, mesmo que o` &lt;branch&gt; <code>não seja único em todos
os remotos . Definir como, por exemplo `verificar.padrãoRemoto=origem</code> para
sempre verificar as ramificações remotas de lá se` &lt;branch&gt; <code>for ambíguo,
mas existir no remoto de 'origem'. Veja também `verificar.padrãoRemoto</code> no
<a href="gitconfig.html">gitconfig(1)</a>.</p></div>
<div class="paragraph"><p>Você pode omitir &lt;branch&gt;, caso em que o comando se degenera para "verificar
o branch atual", que é um glorificado não-op com efeitos colaterais bastante
caros para mostrar apenas as informações de rastreamento, se existir, para o
branch atual.</p></div>
</dd>
<dt class="hdlist1">
<em>git verificar</em> -b|-B &lt;novo_branch&gt; [&lt;start point&gt;]
</dt>
<dd>
<p>
        Especificar <code>-b</code> faz com que uma nova ramificação seja criada como se
        <a href="git-branch.html">git-branch(1)</a> fosse chamado e, em seguida, retirado. Neste caso você
        pode usar as opções <code>--track</code> ou` --não-track`, que serão passadas para <em>git
        branch</em>. Por conveniência, <code>--track</code> sem` -b` implica criação de
        ramificação; veja a descrição de <code>--track</code> abaixo.
</p>
<div class="paragraph"><p>Se <code>-B</code> é dado, &lt;novo_branch&gt; é criado se não existir; caso contrário, é
redefinido. Este é o equivalente transacional de</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git branch -f &lt;branch&gt; [&lt;ponto de partida&gt;]
$ git verificar &lt;branch&gt;</code></pre>
</div></div>
<div class="paragraph"><p>isto é, a ramificação não é redefinida/criada a menos que "git verificar"
seja bem-sucedido.</p></div>
</dd>
<dt class="hdlist1">
<em>git verificar</em> --desanexar [&lt;branch&gt;]
</dt>
<dt class="hdlist1">
<em>git verificar</em> [--desanexar] &lt;commit&gt;
</dt>
<dd>
<p>
        Prepare-se para trabalhar em cima de &lt;commit&gt;, desanexando HEAD nele
        (consulte a seção "DESTACADO HEAD") e atualizando o índice e os arquivos na
        árvore de trabalho.  As modificações locais nos arquivos na árvore de
        trabalho são mantidas, de forma que a árvore de trabalho resultante seja o
        estado registrado no commit mais as modificações locais.
</p>
<div class="paragraph"><p>Quando o argumento &lt;commit&gt; é um nome de ramificação, a opção <code>--desanexar</code>
pode ser usada para desanexar HEAD na ponta da ramificação (` git verificar
&lt;branch&gt; `veria aquela ramificação sem desanexar HEAD).</p></div>
<div class="paragraph"><p>Omitir &lt;branch&gt; desanexa o HEAD na ponta do ramo atual.</p></div>
</dd>
<dt class="hdlist1">
<em>git verificar</em> [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;&#8230;
</dt>
<dd>
<p>
        Sobrescreva caminhos na árvore de trabalho substituindo o conteúdo no índice
        ou no &lt;tree-ish&gt; (na maioria das vezes uma confirmação).
         Quando um &lt;tree-ish&gt; é fornecido, os caminhos que correspondem ao
        &lt;pathspec&gt; são atualizados no índice e na árvore de trabalho.
</p>
<div class="paragraph"><p>O índice pode conter entradas não mescladas devido a uma mesclagem anterior
com falha.  Por padrão, se você tentar verificar essa entrada do índice, a
operação de check-out falhará e nada será retirado. Usar <code>-f</code> irá ignorar
essas entradas não-mescladas.  O conteúdo de um lado específico da mesclagem
pode ser retirado do índice usando <code>--ours</code> ou` --theirs`.  Com <code>-m</code>, as
alterações feitas no arquivo da árvore de trabalho podem ser descartadas
para recriar o resultado da mesclagem original em conflito.</p></div>
</dd>
<dt class="hdlist1">
<em>git verificar</em> (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;pathspec&gt;&#8230;]
</dt>
<dd>
<p>
        Isso é semelhante ao "verificar paths para a árvore de trabalho do modo de
        índice ou de árvore-ish" descrito acima, mas permite usar a interface
        interativa para mostrar a saída "diff" e escolher quais blocos usar no
        resultado.  Veja abaixo a descrição da opção <code>--patch</code>.
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_opções">OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
-q
</dt>
<dt class="hdlist1">
--quiet
</dt>
<dd>
<p>
        Silencioso, suprima as mensagens de feedback.
</p>
</dd>
<dt class="hdlist1">
--[no-]progress
</dt>
<dd>
<p>
        O status de progresso é relatado no fluxo de erro padrão por padrão quando
        ele é anexado a um terminal, a menos que <code>--quiet</code> seja especificado. Este
        sinalizador permite relatórios de progresso, mesmo que não estejam anexados
        a um terminal, independentemente de <code>--quiet</code>.
</p>
</dd>
<dt class="hdlist1">
-f
</dt>
<dt class="hdlist1">
--force
</dt>
<dd>
<p>
        Ao alternar as ramificações, continue mesmo se o índice ou a árvore de
        trabalho diferirem de HEAD.  Isso é usado para jogar fora as alterações
        locais.
</p>
<div class="paragraph"><p>Ao verificar os caminhos do índice, não falhe em entradas não mescladas; Em
vez disso, as entradas não mescladas são ignoradas.</p></div>
</dd>
<dt class="hdlist1">
--ours
</dt>
<dt class="hdlist1">
--theirs
</dt>
<dd>
<p>
        Ao verificar os caminhos do índice, confira o estágio #2 (<em>nosso</em>) ou #3
        (<em>deles</em>) para paths não mesclados.
</p>
<div class="paragraph"><p>Note que durante o <code>git rebase</code> e` git pull --rebase`, <em>ours</em> e <em>theirs</em>
podem aparecer trocados; <code>--ours</code> fornece a versão da ramificação onde as
alterações são feitas, enquanto` --theirs` fornece a versão da ramificação
que contém o seu trabalho que está sendo rebaixado.</p></div>
<div class="paragraph"><p>Isso ocorre porque o <code>rebase</code> é usado em um fluxo de trabalho que trata o
histórico no remoto como o canônico compartilhado e trata o trabalho
realizado na ramificação que você está rebaixando como o trabalho de
terceiros a ser integrado, e você está temporariamente assumindo o papel do
guardião da história canônica durante o rebase.
 Como guardião da história canônica, você precisa ver a história do controle
remoto como "nosso" (isto é, "nossa história canônica compartilhada"),
enquanto o que você fez em seu ramo lateral como "seu" (isto é, "um trabalho
de colaborador" em cima dele ").</p></div>
</dd>
<dt class="hdlist1">
-b &lt;novo_branch&gt;
</dt>
<dd>
<p>
        Crie uma nova ramificação chamada &lt;novo_branch&gt; e inicie-a em
        &lt;ponto_de_partida&gt;; veja <a href="git-branch.html">git-branch(1)</a> para detalhes.
</p>
</dd>
<dt class="hdlist1">
-B &lt;novo_branch&gt;
</dt>
<dd>
<p>
        Cria o ramo &lt;novo_branch&gt; e inicia em &lt;ponto_de_partida&gt;; se já existir,
        redefina-o para &lt;ponto_de_partida&gt;. Isso é equivalente a executar "git
        branch" com "-f"; veja <a href="git-branch.html">git-branch(1)</a> para detalhes.
</p>
</dd>
<dt class="hdlist1">
-t
</dt>
<dt class="hdlist1">
--track
</dt>
<dd>
<p>
        Ao criar um novo branch, configure "upstream". Veja "--track" em
        <a href="git-branch.html">git-branch(1)</a> para detalhes.
</p>
<div class="paragraph"><p>Se nenhuma opção <code>-b</code> for fornecida, o nome da nova ramificação será
derivado da ramificação de controle remoto, observando a parte local da
refspec configurada para o controle remoto correspondente e, em seguida,
removendo a parte inicial para o "*".  Isso nos diria para usar "hack" como
a ramificação local ao se ramificar de "origin/hack" (ou "remotos/origem/
hack", ou mesmo "refs/remotos/ origem/ hack").  Se o nome dado não tiver
barra, ou se a suposição acima resultar em um nome vazio, a adivinhação será
abortada. Você pode dar explicitamente um nome com <code>-b</code> em tal caso.</p></div>
</dd>
<dt class="hdlist1">
--no-track
</dt>
<dd>
<p>
        Não configure "upstream", mesmo que a variável de configuração
        branch.autoSetupMerge seja verdadeira.
</p>
</dd>
<dt class="hdlist1">
-l
</dt>
<dd>
<p>
        Crie o reflog da nova ramificação; veja <a href="git-branch.html">git-branch(1)</a> para detalhes.
</p>
</dd>
<dt class="hdlist1">
--detach
</dt>
<dd>
<p>
        Em vez de verificar um ramo para trabalhar nele, confira um commit para
        inspeções e experiências descartáveis.  Este é o comportamento padrão de
        "git checkout &lt;commit&gt;" quando &lt;commit&gt; não é um nome de ramificação. Veja a
        seção "DESTACADO CABEÇA" abaixo para detalhes.
</p>
</dd>
<dt class="hdlist1">
--orfão &lt;novo_branch&gt;
</dt>
<dd>
<p>
        Crie uma nova ramificação <em>órfã</em>, denominada &lt;novo_branch&gt;, iniciada a
        partir de &lt;ponto_de_partida&gt; e mude para ela. O primeiro commit feito nesta
        nova branch não terá pais e será a raiz de uma nova história totalmente
        desconectada de todas as outras ramificações e commits.
</p>
<div class="paragraph"><p>O índice e a árvore de trabalho são ajustados como se você tivesse executado
anteriormente "git checkout &lt;ponto_de_partida&gt;". Isso permite que você
inicie um novo histórico que registra um conjunto de paths semelhante ao
&lt;ponto_de_partida&gt; executando facilmente "git commit -a" para fazer o commit
raiz.</p></div>
<div class="paragraph"><p>Isso pode ser útil quando você deseja publicar a árvore de um commit sem
expor seu histórico completo. Você pode querer fazer isso para publicar uma
ramificação de código aberto de um projeto cuja árvore atual esteja "limpa",
mas cujo histórico completo contenha bits de código proprietários ou de
outra forma onerados.</p></div>
<div class="paragraph"><p>Se você quiser iniciar um histórico desconectado que registra um conjunto de
caminhos totalmente diferente do &lt;start_point&gt;, então você deve limpar o
índice e a árvore de trabalho logo após criar o branch órfão executando "git
rm -rf. " do nível superior da árvore de trabalho. Depois disso, você estará
pronto para preparar seus novos arquivos, preenchendo a árvore de trabalho,
copiando-os de outro lugar, extraindo um tarball, etc.</p></div>
</dd>
<dt class="hdlist1">
--ignore-skip-worktree-bits
</dt>
<dd>
<p>
        No modo de checkout esparso, <code>git checkout - &lt;paths&gt;</code> atualizaria apenas
        entradas correspondidas por &lt;paths&gt; e padrões esparsos em
        $GIT_DIR/info/sparse-checkout. Esta opção ignora os padrões esparsos e
        adiciona de volta os arquivos em &lt;paths&gt;.
</p>
</dd>
<dt class="hdlist1">
-m
</dt>
<dt class="hdlist1">
--merge
</dt>
<dd>
<p>
        Ao alternar ramificações, se você tiver modificações locais em um ou mais
        arquivos que sejam diferentes entre a ramificação atual e a ramificação para
        a qual você está alternando, o comando se recusará a alternar as
        ramificações para preservar suas modificações no contexto.  No entanto, com
        essa opção, uma mesclagem de três vias entre a ramificação atual, o conteúdo
        da árvore de trabalho e a nova ramificação é concluída e você estará na nova
        ramificação.
</p>
<div class="paragraph"><p>Quando ocorre um conflito de mesclagem, as entradas de índice para caminhos
conflitantes são deixadas sem migração, e você precisa resolver os conflitos
e marcar os paths resolvidos com <code>git add</code> (ou` git rm` se a mesclagem
resultar na exclusão do caminho) .</p></div>
<div class="paragraph"><p>Ao efetuar o check-out de caminhos do índice, essa opção permite recriar a
mesclagem conflitante nos caminhos especificados.</p></div>
</dd>
<dt class="hdlist1">
--conflito=&lt;estilo&gt;
</dt>
<dd>
<p>
        O mesmo que a opção --merge acima, mas altera a forma como os blocos
        conflitantes são apresentados, substituindo a variável de configuração
        merge.conflictStyle.  Os valores possíveis são "merge" (padrão) e "diff3"
        (além do que é mostrado pelo estilo "merge", mostra o conteúdo original).
</p>
</dd>
<dt class="hdlist1">
-p
</dt>
<dt class="hdlist1">
--patch
</dt>
<dd>
<p>
        Selecione interativamente os pedaços na diferença entre o &lt;tree-ish&gt; (ou o
        índice, se não especificado) e a árvore de trabalho.  Os pedaços escolhidos
        são então aplicados em reverso à árvore de trabalho (e se um &lt;tree-ish&gt; for
        especificado, o índice).
</p>
<div class="paragraph"><p>Isso significa que você pode usar o &#8216;git checkout -p` para descartar
seletivamente as edições da sua árvore de trabalho atual. Veja a seção ``
Interactive Mode '&#8217; do <a href="git-add.html">git-add(1)</a> para aprender como operar o modo
<code>--patch</code>.</p></div>
</dd>
<dt class="hdlist1">
--ignore-other-worktrees
</dt>
<dd>
<p>
        <code>git checkout</code> recusa-se quando a referência desejada já foi verificada por
        outra worktree. Esta opção faz com que verifique o ref fora de qualquer
        maneira. Em outras palavras, o ref pode ser mantido por mais de uma árvore
        de trabalho.
</p>
</dd>
<dt class="hdlist1">
--[no-]recurse-submodules
</dt>
<dd>
<p>
        Usando --recurso-submódulos irá atualizar o conteúdo de todos os submódulos
        inicializados de acordo com o commit registrado no superprojeto. Se
        modificações locais em um submódulo forem sobrescritas, o check-out falhará,
        a menos que <code>-f</code> seja usado. Se nada (ou --não-recurso-submódulos)  for
        usado, as árvores de trabalho dos submódulos não serão atualizadas. Assim
        como o <a href="git-submodule.html">git-submodule(1)</a>, isso desanexará os submódulos HEAD.
</p>
</dd>
<dt class="hdlist1">
--no-guess
</dt>
<dd>
<p>
        Não tente criar uma ramificação se existir uma ramificação de rastreamento
        remoto com o mesmo nome.
</p>
</dd>
<dt class="hdlist1">
&lt;branch&gt;
</dt>
<dd>
<p>
        Filial para check-out; se refere-se a um ramo (isto é, um nome que, quando
        prefixado com "refs/heads/", é um ref válido), então esse ramo é
        retirado. Caso contrário, se se referir a um commit válido, seu HEAD se
        torna "separado" e você não está mais em nenhum branch (veja abaixo para
        detalhes).
</p>
<div class="paragraph"><p>Você pode usar a sintaxe <code>" @{- N}"</code> para se referir à última branch/commit
finalizada usando a operação "git checkout". Você também pode especificar
<code>-</code> que é sinônimo de` "@{- 1}`.</p></div>
<div class="paragraph"><p>Como um caso especial, você pode usar <code>"A ... B"</code> como um atalho para a base
de mesclagem de <code>A</code> e` B` se houver exatamente uma base de merge. Você pode
deixar de fora, no máximo, um de <code>A</code> e` B`, caso em que o padrão é <code>HEAD</code>.</p></div>
</dd>
<dt class="hdlist1">
&lt;novo_branch&gt;
</dt>
<dd>
<p>
        Nome para o novo branch.
</p>
</dd>
<dt class="hdlist1">
&lt;ponto_de_partida&gt;
</dt>
<dd>
<p>
        O nome de um commit no qual iniciar o novo branch; veja
        <a href="git-branch.html">git-branch(1)</a> para detalhes. Padrão para HEAD.
</p>
</dd>
<dt class="hdlist1">
&lt;tree-ish&gt;
</dt>
<dd>
<p>
        Árvore para checkout (quando os paths são dados). Se não especificado, o
        índice será usado.
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_cabeça_destacada">CABEÇA DESTACADA</h2>
<div class="sectionbody">
<div class="paragraph"><p>HEAD normalmente se refere a uma ramificação nomeada (por exemplo,
<em>mestre</em>). Enquanto isso, cada ramo se refere a um commit específico. Vamos
olhar para um repositório com três commits, um deles marcado, e com branch
<em>master</em> check out:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>           HEAD (refers to branch 'master')
            |
            v
a---b---c  branch 'master' (refers to commit 'c')
    ^
    |
  tag 'v2.0' (refers to commit 'b')</code></pre>
</div></div>
<div class="paragraph"><p>Quando uma confirmação é criada nesse estado, a ramificação é atualizada
para se referir à nova confirmação. Especificamente, <em>git commit</em> cria um
novo commit <em>d</em>, cujo pai é commit <em>c</em>, e então atualiza o branch <em>master</em>
para se referir ao novo commit <em>d</em>. HEAD ainda se refere à ramificação
<em>master</em> e então indiretamente agora se refere a commit <em>d</em>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ editar; git adicionar; git commit

               HEAD (refers to branch 'master')
                |
                v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')</code></pre>
</div></div>
<div class="paragraph"><p>Às vezes, é útil poder fazer o checkout de uma confirmação que não esteja na
ponta de qualquer ramificação nomeada, ou mesmo criar uma nova confirmação
que não seja referenciada por uma ramificação nomeada. Vejamos o que
acontece quando fazemos o checkout commit <em>b</em> (aqui mostramos duas maneiras
pelas quais isso pode ser feito):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar v2.0  # ou
$ git verificar master^^

   HEAD (refers to commit 'b')
    |
    v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')</code></pre>
</div></div>
<div class="paragraph"><p>Observe que, independentemente do comando de checkout usado, o HEAD agora se
refere diretamente ao commit <em>b</em>. Isso é conhecido como estando no estado
HEAD separado. Significa simplesmente que HEAD se refere a um commit
específico, ao invés de se referir a um branch nomeado. Vamos ver o que
acontece quando criamos um commit:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ editar; git adicionar; git commit

     HEAD (refers to commit 'e')
      |
      v
      e
     /
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')</code></pre>
</div></div>
<div class="paragraph"><p>Existe agora um novo commit <em>e</em>, mas é referenciado apenas pelo
HEAD. Podemos, claro, adicionar mais um commit nesse estado:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ editar; git adicionar; git commit

         HEAD (refers to commit 'f')
          |
          v
      e---f
     /
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')</code></pre>
</div></div>
<div class="paragraph"><p>Na verdade, podemos executar todas as operações normais do Git. Mas, vamos
ver o que acontece quando, então, fazemos o checkout master:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar master

               HEAD (refers to branch 'master')
      e---f     |
     /          v
a---b---c---d  branch 'master' (refers to commit 'd')
    ^
    |
  tag 'v2.0' (refers to commit 'b')</code></pre>
</div></div>
<div class="paragraph"><p>É importante perceber que neste ponto nada se refere ao commit
<em>f</em>. Eventualmente, o commit <em>f</em> (e por extensão commit <em>e</em>) será deletado
pelo processo de coleta de lixo do Git, a não ser que criemos uma referência
antes que isso aconteça. Se ainda não tivermos mudado do commit <em>f</em>,
qualquer um deles criará uma referência a ele:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar -b foo   <b>&lt;1&gt;</b>
$ git branch foo        <b>&lt;2&gt;</b>
$ git tag foo           <b>&lt;3&gt;</b></code></pre>
</div></div>
<div class="colist arabic"><ol>
<li>
<p>
cria um novo branch <em>foo</em>, que se refere a commit <em>f</em>, e então atualiza HEAD
    para se referir a branch <em>foo</em>. Em outras palavras, não estaremos mais no
    estado HEAD separado após este comando.
</p>
</li>
<li>
<p>
similarmente cria uma nova ramificação <em>foo</em>, que se refere ao commit <em>f</em>,
    mas deixa o HEAD desanexado.
</p>
</li>
<li>
<p>
cria uma nova tag <em>foo</em>, que se refere ao commit <em>f</em>, deixando o HEAD
    desanexado.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Se nos afastamos do commit <em>f</em>, devemos primeiro recuperar o nome do objeto
(geralmente usando o git reflog), e então podemos criar uma referência para
ele. Por exemplo, para ver os dois últimos commits aos quais o HEAD se
referiu, podemos usar um destes comandos:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git reflog -2 HEAD # or
$ git log -g -2 HEAD</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_disambiguação_de_argumentos">DISAMBIGUAÇÃO DE ARGUMENTOS</h2>
<div class="sectionbody">
<div class="paragraph"><p>Quando há apenas um argumento dado e não é <code>--</code> (eg" git checkout abc"), e
quando o argumento é ambos um` &lt;tree-ish&gt; <code>válido (ex. Um ramo" abc "existe)
e um válido `&lt;pathspec&gt;</code> (por exemplo, um arquivo ou diretório cujo nome é
"abc" existe), o Git normalmente pede para você desambiguar. Como o
check-out de uma ramificação é uma operação tão comum, no entanto, "git
checkout abc" toma "abc" como um <code>&lt;tree-ish&gt;</code> em tal situação. Use <code>git
checkout - &lt;pathspec&gt;</code> se você quiser fazer o checkout desses caminhos fora
do índice.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos">EXEMPLOS</h2>
<div class="sectionbody">
<div class="olist arabic"><ol class="arabic">
<li>
<p>
A sequência a seguir faz o checkout do branch <code>master</code>, reverte o` Makefile`
  para duas revisões, apaga hello.c por engano e o recupera do índice.
</p>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar master             <b>&lt;1&gt;</b>
$ git verificar master~2 Fazer arquivo  <b>&lt;2&gt;</b>
$ rm -f hello.c
$ git verificar hello.c            <b>&lt;3&gt;</b></code></pre>
</div></div>
<div class="colist arabic"><ol>
<li>
<p>
comutação de branch
</p>
</li>
<li>
<p>
tirar um arquivo de outro commit
</p>
</li>
<li>
<p>
restaurar o hello.c do índice
</p>
<div class="paragraph"><p>Se você quiser dar uma olhada nos arquivos de código-fonte, todos fora do
índice, você pode dizer</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar -- '*.c'</code></pre>
</div></div>
<div class="paragraph"><p>Observe as aspas em torno de <code>* .c</code>.  O arquivo <code>hello.c</code> também será
retirado, mesmo que não esteja mais na árvore de trabalho, porque o
agrupamento de arquivos é usado para corresponder entradas no índice (não na
árvore de trabalho pelo shell).</p></div>
<div class="paragraph"><p>Se você tem um ramo infeliz chamado <code>hello.c</code>, este passo seria confundido
como uma instrução para mudar para esse ramo.  Você deve escrever:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar -- hello.c</code></pre>
</div></div>
</li>
</ol></div>
</li>
<li>
<p>
Depois de trabalhar no ramo errado, mudar para o ramo correto seria feito
  usando:
</p>
<div class="listingblock">
<div class="content">
<pre><code>$ git checkout meu tópico</code></pre>
</div></div>
<div class="paragraph"><p>No entanto, sua ramificação "errada" e a ramificação "meu tópico" correta
podem diferir nos arquivos que você modificou localmente. Nesse caso, a
verificação acima falharia assim:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar meu tópico
erro: você tem alterações locais em 'frotz'; não comutação de branches.</code></pre>
</div></div>
<div class="paragraph"><p>Você pode dar o sinalizador <code>-m</code> ao comando, que tentaria uma merge de três
vias:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar -m meu tópico
Auto-merging frotz</code></pre>
</div></div>
<div class="paragraph"><p>Após essa mesclagem de três vias, as modificações locais não serão
registradas em seu arquivo de índice, portanto, o <code>git diff</code> mostrará quais
alterações foram feitas desde a dica da nova ramificação.</p></div>
</li>
<li>
<p>
Quando um conflito de mesclagem acontece durante a troca de branches com a
  opção <code>-m</code>, você veria algo assim:
</p>
<div class="listingblock">
<div class="content">
<pre><code>$ git verificar -m meu tópico
Auto-merging frotz
ERRO: Merger conflito em frotz
fatal: falha no programa de merge</code></pre>
</div></div>
<div class="paragraph"><p>Neste ponto, o <code>git diff</code> mostra as mudanças mescladas como no exemplo
anterior, bem como as mudanças nos arquivos conflitantes.
 Editar e resolver o conflito e marcá-lo resolvido com <code>git add</code> como de
costume:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ editar frotz
$ git adicionar frotz</code></pre>
</div></div>
</li>
</ol></div>
</div>
</div>
<div class="sect1">
<h2 id="_git">GIT</h2>
<div class="sectionbody">
<div class="paragraph"><p>Parte do linkgit: git[1] suite</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-06-16 22:08:34 CEST
</div>
</div>
</body>
</html>
